{"google":"","note":"Don't delete this file! It's used internally to help with page regeneration.","body":"# Promised #.\r\n\r\nConvert back and forth from javascript Promises to Callbacks\r\n\r\nThis library works on both node and browser.\r\nCurrently it supports jQuery and Q promises.\r\n\r\n[jQuery]: [http://api.jquery.com/category/deferred-object]\r\n[Q]: [http://documentup.com/kriskowal/q/]\r\n\r\n## Usage ##\r\n\r\n```javascript\r\nvar P = require('promised') // or window.promised in browsers\r\n\r\nvar promisedQ = P.Q( Q )      // Use Promised with Q deferreds\r\nvar promisedJ = P.$( jQuery ) // Use Promised with JQuery deferreds\r\n\r\n// Or you can give P two functions:\r\n//\r\n// deferrer: takes a single argument and creates a deferred object\r\n//           with it or returns it if already a referred.\r\n//\r\n// promiser: takes a deferred object and returns a promise for it\r\n//\r\n\r\nvar promisedCustom = P( defferer, promiser )\r\n\r\n```\r\n\r\n## API ##\r\n\r\nIn the following signatures `callback<e,s>` means a function that\r\ntakes two arguments, one for error and the second for success. And\r\n`callback<v>` is a function that takes a single value; in node\r\nAPI these kind of callbacks are used for predicates, functions that\r\neither invoke the callback with true or false, that's why each of\r\nthe following functions has a `p.` version which works with this\r\nkind of predicate callbacks.\r\n\r\n### Deferred generator to Callback receiver ###\r\n\r\n`P(function, receiver, args...)` -> `function(args..., callback<e,s>)`\r\n\r\n`P.p(function, receiver, args...)` -> `function(args..., callback<v>)`\r\n\r\nThis transformation takes a function that will return a _deferred_ and\r\nwill transform it into a function that expects any number of arguments\r\nand a _callback_ as the last one.\r\n\r\n```\r\nP(jQuery.ajax, jQuery)\r\n\r\n// is equivalent to\r\nfunction(args..., callback) {\r\n  var deferred = jQuery.ajax(args...)\r\n    , promise = deferred.promise()\r\n  promise.then(callbackSuccess, callbackError)\r\n}\r\n```\r\n\r\nFunctions returned by `P` can be curried by using it's `curry` method.\r\nThis way you can add arguments to the function without yet invoking it.\r\n\r\n`_.curry(args...)` -> `function(args..., callback<e,s>)`\r\n\r\n### Forward a Promise to Callback arguments ###\r\n\r\n`P.fwd(promise, callback<e, s>)`\r\n\r\n`P.p.fwd(promise, callback<v>)`\r\n\r\nWhen the given _promise_ is resolved/rejected, the _callback_ is called\r\naccordingly.\r\n\r\n\r\n### Turn a Deferred into a Callback ###\r\n\r\n`P.bwd(deferred)` -> `function(error, success)`\r\n\r\n`P.p.bwd(deferred)` -> `function(value)`\r\n\r\nWhen the returned _callback_ is given an error argument, the\r\n_deferred_ will be rejected, otherwise it will be resolved.\r\n\r\n### Turn a Promise into a Function that takes a callback and resolves ###\r\n\r\n`P.get(promise)` -> `function(callback<e,s>){ resolve(s)/reject(e) }`\r\n`P.p.get(promise)` -> `function(callback<v>){ promise.resolve(v) }`\r\n\r\nIf given multiple _promise_s, `.get` will return an array of functions.\r\n\r\n### Turn a Deferred into a Function (callback) that resolves/rejects ###\r\n\r\n`P.set(deferred)` -> `function(error, success) { resolve(success)/reject(error) }`\r\n`P.p.set(deferred)` -> `function(value) { resolve(value) }`\r\n\r\nIf `p.set` is given multiple _deferred_s each of them will be resolved\r\nto the corresponding argument the _callback_ is called with.\r\nIf `.set` is given multiple _deferred_s all of them will be\r\nresolved/rejected to the same value.\r\n\r\n\r\n","tagline":"Convert back and forth from javascript Promises to Callbacks","name":"Promised"}